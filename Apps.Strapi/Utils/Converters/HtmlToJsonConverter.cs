using Apps.Strapi.Constants;
using Apps.Strapi.Models.Records;
using Blackbird.Applications.Sdk.Common.Exceptions;
using HtmlAgilityPack;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System.Web;

namespace Apps.Strapi.Utils.Converters;

public static class HtmlToJsonConverter
{
    public static HtmlMetadata ExtractMetadata(string metadata)
    {
        try
        {
            var doc = new HtmlDocument();
            doc.LoadHtml(metadata);

            var contentIdNode = doc.DocumentNode.SelectSingleNode($"//meta[@name='{MetadataKeys.ContentId}']");
            var contentTypeIdNode = doc.DocumentNode.SelectSingleNode($"//meta[@name='{MetadataKeys.ContentType}']");
            var languageNode = doc.DocumentNode.SelectSingleNode($"//meta[@name='{MetadataKeys.Locale}']");
            if (contentTypeIdNode != null && languageNode != null)
            {
                var contentId = contentIdNode?.GetAttributeValue("content", string.Empty);
                var contentTypeId = contentTypeIdNode.GetAttributeValue("content", string.Empty);
                var language = languageNode.GetAttributeValue("content", string.Empty);

                return new HtmlMetadata(string.IsNullOrEmpty(contentId) ? null : contentId, contentTypeId, language);
            }

            throw new PluginApplicationException("HTML document does not contain the required metadata. Make sure the HTML is generated by the connector.");
        }
        catch (Exception ex) when (ex.Message.Contains("node-set") || ex.Message.Contains("unclosed string"))
        {
            throw new PluginApplicationException("Failed to parse HTML metadata. The HTML content may contain invalid characters or be malformed. Please ensure the HTML file is properly formatted.", ex);
        }
    }

    public static string ConvertToJson(string html, string strapiVersion, string targetLocale)
    {
        JObject jsonObj;
        JObject originalJsonObj;
        try
        {
            html = NormalizeHtmlTags(html);
            
            var doc = new HtmlDocument();
            doc.LoadHtml(html);

            var bodyNode = doc.DocumentNode.SelectSingleNode("//body");
            if (bodyNode == null)
            {
                throw new PluginApplicationException("HTML document does not contain a body tag");
            }

            var originalJsonEncoded = bodyNode.GetAttributeValue("original", string.Empty);
            if (string.IsNullOrEmpty(originalJsonEncoded))
            {
                throw new PluginApplicationException("HTML does not contain the original JSON data");
            }

            var originalJson = HttpUtility.HtmlDecode(originalJsonEncoded);
            originalJsonObj = JsonConvert.DeserializeObject<JObject>(originalJson)!;
            jsonObj = JsonConvert.DeserializeObject<JObject>(originalJson)!;

            if (jsonObj == null)
            {
                throw new PluginApplicationException("Failed to parse original JSON data");
            }

            ProcessPropertyValues(doc, jsonObj);
            ProcessMarkdownContent(doc, jsonObj);
            ProcessRichTextContent(doc, jsonObj);
        }
        catch (Exception ex) when (ex.Message.Contains("node-set") || ex.Message.Contains("unclosed string"))
        {
            throw new PluginApplicationException("Failed to parse HTML content. The HTML may contain special characters or invalid XPath expressions. This often happens with quotes or apostrophes in content titles.", ex);
        }
        catch (PluginApplicationException)
        {
            throw;
        }
        catch (Exception ex)
        {
            throw new PluginApplicationException($"Unexpected error during HTML to JSON conversion: {ex.Message}", ex);
        }

        var dataObj = jsonObj["data"] as JObject;
        if (dataObj == null)
        {
            throw new PluginApplicationException("Invalid JSON structure: missing 'data' property");
        }

        foreach (var property in JsonProperties.NonLocalizableProperties)
        {
            if (dataObj.ContainsKey(property))
            {
                dataObj.Remove(property);
            }
        }

        if (dataObj.ContainsKey("attributes") && dataObj["attributes"] is JObject attributesObj)
        {
            foreach (var property in attributesObj.Properties())
            {
                if (!JsonProperties.NonLocalizableProperties.Contains(property.Name))
                {
                    dataObj[property.Name] = property.Value;
                }
            }
            
            dataObj.Remove("attributes");
            if (strapiVersion == StrapiVersions.V4)
            {
                dataObj.Add("locale", targetLocale);
            }
        }

        // Restore base64 images from the original JSON after all processing is complete
        var originalDataObj = originalJsonObj["data"] as JObject;
        if (originalDataObj != null)
        {
            RestoreBase64Images(dataObj, originalDataObj);
        }

        if (strapiVersion == StrapiVersions.V4)
        {
            return JsonConvert.SerializeObject(dataObj);
        }
        
        return JsonConvert.SerializeObject(new { data = dataObj });
    }

    private static string NormalizeHtmlTags(string html)
    {
        // Replace fullwidth characters that LLM models sometimes produce. These replacements fix corrupted HTML tags from translation
        return html
            .Replace("＜", "<")     // Fullwidth less-than
            .Replace("＞", ">")     // Fullwidth greater-than
            .Replace("＂", "\"")    // Fullwidth quotation mark
            .Replace("'", "'")      // Left single quotation mark
            .Replace("'", "'")      // Right single quotation mark
            .Replace("／", "/")     // Fullwidth solidus
            .Replace("＝", "=");    // Fullwidth equals sign
    }

    private static void ProcessPropertyValues(HtmlDocument doc, JObject jsonObj)
    {
        try
        {
            var propertyValueNodes = doc.DocumentNode.SelectNodes("//span[@class='property-value'] | //div[@class='property-value']");
            if (propertyValueNodes == null)
                return;

            foreach (var node in propertyValueNodes)
            {
                var jsonPath = node.GetAttributeValue("data-json-path", string.Empty);
                if (string.IsNullOrEmpty(jsonPath))
                {
                    continue;
                }

                var isHtmlContent = node.GetAttributeValue("data-html", string.Empty);
                if (isHtmlContent == "true")
                {
                    UpdateJsonProperty(jsonObj, jsonPath, node.InnerHtml);
                }
                else
                {
                    UpdateJsonProperty(jsonObj, jsonPath, node.InnerText);
                }
            }
        }
        catch (Exception ex) when (ex.Message.Contains("node-set") || ex.Message.Contains("unclosed string"))
        {
            throw new PluginApplicationException("Failed to process property values from HTML. XPath expression failed, likely due to special characters in the HTML content.", ex);
        }
    }

    private static void ProcessMarkdownContent(HtmlDocument doc, JObject jsonObj)
    {
        try
        {
            var markdownContainers = doc.DocumentNode.SelectNodes("//div[@class='md-rich-text']");
            if (markdownContainers == null)
            {
                return;
            }

            foreach (var container in markdownContainers)
            {
                var jsonPath = container.GetAttributeValue("data-json-path", string.Empty);
                if (string.IsNullOrEmpty(jsonPath))
                {
                    continue;
                }

                var markdownContent = MarkdownConverter.ToMarkdown(container);
                UpdateJsonProperty(jsonObj, jsonPath, markdownContent);
            }
        }
        catch (Exception ex) when (ex.Message.Contains("node-set") || ex.Message.Contains("unclosed string"))
        {
            throw new PluginApplicationException("Failed to process markdown content from HTML. XPath expression failed, likely due to special characters in the HTML content.", ex);
        }
    }

    private static void ProcessRichTextContent(HtmlDocument doc, JObject jsonObj)
    {
        try
        {
            var richTextContainers = doc.DocumentNode.SelectNodes("//div[@class='rich-text-content']");
            if (richTextContainers == null)
            {
                return;
            }

            foreach (var container in richTextContainers)
            {
                var jsonPath = container.GetAttributeValue("data-json-path", string.Empty);
                if (string.IsNullOrEmpty(jsonPath))
                {
                    continue;
                }

                var blocks = container.ChildNodes.Where(n => n.NodeType == HtmlNodeType.Element).ToList();
                var richTextArray = new JArray();

                foreach (var block in blocks)
                {
                    var blockPath = block.GetAttributeValue("data-json-path", string.Empty);
                    if (string.IsNullOrEmpty(blockPath))
                    {
                        continue;
                    }

                    var blockJson = RichTextConverter.BuildBlock(block);
                    if (blockJson != null)
                    {
                        richTextArray.Add(blockJson);
                    }
                }

                SetValueAtPath(jsonObj, jsonPath, richTextArray);
            }
        }
        catch (Exception ex) when (ex.Message.Contains("node-set") || ex.Message.Contains("unclosed string"))
        {
            throw new PluginApplicationException("Failed to process rich text content from HTML. XPath expression failed, likely due to special characters in the HTML content.", ex);
        }
    }

    private static void UpdateJsonProperty(JObject json, string path, string value)
    {
        SetValueAtPath(json, path, value);
    }

    private static void SetValueAtPath(JObject json, string path, object value)
    {
        JToken valueToken = value is JToken token ? token : JToken.FromObject(value);

        var pathSegments = ParseJsonPath(path);
        if (pathSegments.Count == 0)
            return;

        JToken current = json;
        for (int i = 0; i < pathSegments.Count - 1; i++)
        {
            var segment = pathSegments[i];

            if (segment.IsArrayIndex)
            {
                if (current![segment.Name] is JArray array && array.Count > segment.Index)
                    current = array[segment.Index];
                else
                    return;
            }
            else
            {
                if (current![segment.Name] == null)
                    return;
                current = current[segment.Name]!;
            }
        }

        var lastSegment = pathSegments[pathSegments.Count - 1];
        if (lastSegment.IsArrayIndex)
        {
            if (current[lastSegment.Name] is JArray array && array.Count > lastSegment.Index)
                array[lastSegment.Index] = valueToken;
        }
        else if (current is JObject obj)
        {
            obj[lastSegment.Name] = valueToken;
        }
    }

    private static List<PathSegment> ParseJsonPath(string path)
    {
        var segments = new List<PathSegment>();
        var parts = path.Split('.');

        foreach (var part in parts)
        {
            if (part.Contains("["))
            {
                var name = part.Substring(0, part.IndexOf('['));
                var indexStr = part.Substring(part.IndexOf('[') + 1, part.IndexOf(']') - part.IndexOf('[') - 1);
                if (int.TryParse(indexStr, out int index))
                {
                    segments.Add(new PathSegment(name, true, index));
                }
            }
            else
            {
                segments.Add(new PathSegment(part, false, 0));
            }
        }

        return segments;
    }

    private class PathSegment
    {
        public string Name { get; }
        public bool IsArrayIndex { get; }
        public int Index { get; }

        public PathSegment(string name, bool isArrayIndex, int index)
        {
            Name = name;
            IsArrayIndex = isArrayIndex;
            Index = index;
        }
    }

    private static void RestoreBase64Images(JToken currentToken, JToken originalToken)
    {
        if (currentToken.Type != originalToken.Type)
            return;

        if (currentToken.Type == JTokenType.Object)
        {
            var currentObj = (JObject)currentToken;
            var originalObj = (JObject)originalToken;

            foreach (var property in currentObj.Properties().ToList())
            {
                if (!originalObj.ContainsKey(property.Name))
                    continue;

                var originalValue = originalObj[property.Name];
                
                // Check if this is a string property
                if (property.Value.Type == JTokenType.String && originalValue?.Type == JTokenType.String)
                {
                    var currentStr = property.Value.ToString();
                    var originalStr = originalValue.ToString();
                    
                    // Check if it contains HTML with placeholder images
                    if (currentStr.Contains("[BASE64_IMAGE_PLACEHOLDER]") && 
                        originalStr.Contains("data:image/"))
                    {
                        // Restore base64 images in HTML content
                        property.Value = RestoreBase64ImagesInHtml(currentStr, originalStr);
                    }
                    // Also handle direct src/url properties
                    else if ((property.Name.Equals("src", StringComparison.OrdinalIgnoreCase) ||
                              property.Name.Equals("url", StringComparison.OrdinalIgnoreCase)) &&
                             currentStr == "[BASE64_IMAGE_PLACEHOLDER]" &&
                             IsBase64Image(originalStr))
                    {
                        property.Value = originalValue;
                    }
                }
                else if (property.Value.Type == JTokenType.Object || property.Value.Type == JTokenType.Array)
                {
                    RestoreBase64Images(property.Value, originalValue!);
                }
            }
        }
        else if (currentToken.Type == JTokenType.Array)
        {
            var currentArray = (JArray)currentToken;
            var originalArray = (JArray)originalToken;

            for (int i = 0; i < Math.Min(currentArray.Count, originalArray.Count); i++)
            {
                RestoreBase64Images(currentArray[i], originalArray[i]);
            }
        }
    }

    private static string RestoreBase64ImagesInHtml(string currentHtml, string originalHtml)
    {
        try
        {
            var currentDoc = new HtmlDocument();
            currentDoc.LoadHtml(currentHtml);
            
            var originalDoc = new HtmlDocument();
            originalDoc.LoadHtml(originalHtml);

            // Find all img tags with placeholders in current HTML
            var currentImgs = currentDoc.DocumentNode.SelectNodes("//img[@src='[BASE64_IMAGE_PLACEHOLDER]']");
            var originalImgs = originalDoc.DocumentNode.SelectNodes("//img");

            if (currentImgs != null && originalImgs != null)
            {
                // Match images by position and restore base64 src
                int placeholderIndex = 0;
                int originalIndex = 0;
                
                while (placeholderIndex < currentImgs.Count && originalIndex < originalImgs.Count)
                {
                    var originalSrc = originalImgs[originalIndex].GetAttributeValue("src", string.Empty);
                    
                    if (IsBase64Image(originalSrc))
                    {
                        // Restore the base64 image
                        currentImgs[placeholderIndex].SetAttributeValue("src", originalSrc);
                        placeholderIndex++;
                    }
                    
                    originalIndex++;
                }
            }

            return currentDoc.DocumentNode.OuterHtml;
        }
        catch
        {
            // If restoration fails, return current content
            return currentHtml;
        }
    }

    private static bool IsBase64Image(string value)
    {
        if (string.IsNullOrEmpty(value))
            return false;

        return value.StartsWith("data:image/", StringComparison.OrdinalIgnoreCase) &&
               value.Contains("base64", StringComparison.OrdinalIgnoreCase) &&
               value.Length > 1000;
    }
}